package hooks

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5/stdlib"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// OpenGORM opens a GORM database handle backed by the given Pool.
// SQL generated by GORM is intercepted and rewritten to target Whisker's
// JSONB document tables for any registered models.
func OpenGORM(p *Pool) (*gorm.DB, error) {
	sqlDB := stdlib.OpenDBFromPool(p.store.PgxPool())

	cp := &gormConnPool{
		db:   sqlDB,
		reg:  p.reg,
		pool: p,
	}

	db, err := gorm.Open(postgres.New(postgres.Config{
		Conn: cp,
	}), &gorm.Config{
		Logger:                 logger.Default.LogMode(logger.Silent),
		SkipDefaultTransaction: true,
	})
	if err != nil {
		sqlDB.Close()
		return nil, fmt.Errorf("hooks: open gorm: %w", err)
	}

	return db, nil
}

// gormConnPool implements gorm.ConnPool by intercepting SQL and rewriting
// it for registered Whisker models before executing against a real *sql.DB.
type gormConnPool struct {
	db   *sql.DB
	reg  *registry
	pool *Pool
}

func (c *gormConnPool) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) {
	return c.db.PrepareContext(ctx, query)
}

func (c *gormConnPool) ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error) {
	rewritten, newArgs := c.rewriteExec(ctx, query, args)
	return c.db.ExecContext(ctx, rewritten, newArgs...)
}

func (c *gormConnPool) QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error) {
	rewritten, newArgs := c.rewriteQuery(query, args)
	return c.db.QueryContext(ctx, rewritten, newArgs...)
}

func (c *gormConnPool) QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row {
	rewritten, newArgs := c.rewriteQuery(query, args)
	return c.db.QueryRowContext(ctx, rewritten, newArgs...)
}

func (c *gormConnPool) rewriteExec(ctx context.Context, query string, args []any) (string, []any) {
	table, op, ok := parseSQL(query)
	if !ok {
		return query, args
	}

	info, found := c.reg.lookupByTable(table)
	if !found {
		return query, args
	}

	switch op {
	case opInsert:
		_ = c.pool.ensureTable(ctx, info)
		rewritten, newArgs, err := rewriteInsert(info, query, args)
		if err != nil {
			return query, args
		}
		return rewritten, newArgs

	case opUpdate:
		rewritten, newArgs, err := rewriteUpdate(info, query, args)
		if err != nil {
			return query, args
		}
		return rewritten, newArgs

	case opDelete:
		rewritten, newArgs, err := rewriteDelete(info, query, args)
		if err != nil {
			return query, args
		}
		return rewritten, newArgs

	case opCreateTable:
		rewritten, err := rewriteCreateTable(info, query)
		if err != nil {
			return query, args
		}
		return rewritten, nil

	default:
		return query, args
	}
}

func (c *gormConnPool) rewriteQuery(query string, args []any) (string, []any) {
	table, op, ok := parseSQL(query)
	if !ok {
		return query, args
	}

	info, found := c.reg.lookupByTable(table)
	if !found {
		return query, args
	}

	if op != opSelect && op != opSelectJoin {
		return query, args
	}

	rewritten, newArgs := rewriteGORMSelect(info, query, args)
	return rewritten, newArgs
}

// rewriteGORMSelect rewrites a SELECT to extract JSONB fields as named columns
// so that database/sql returns proper column names for GORM's scanner.
func rewriteGORMSelect(info *modelInfo, query string, args []any) (string, []any) {
	rewritten := replaceTableName(query, info.name, info.table)

	upper := strings.ToUpper(rewritten)
	whereIdx := strings.Index(upper, " WHERE ")
	if whereIdx >= 0 {
		before := rewritten[:whereIdx+7]
		after := rewritten[whereIdx+7:]
		after = rewriteColumnRefs(after, info)
		rewritten = before + after
	}

	rewritten = rewriteGORMSelectColumns(rewritten, info)
	return rewritten, args
}

// rewriteGORMSelectColumns replaces the column list with JSONB extraction
// expressions that preserve column names for GORM scanning.
func rewriteGORMSelectColumns(query string, info *modelInfo) string {
	upper := strings.ToUpper(query)
	selectIdx := strings.Index(upper, "SELECT ")
	fromIdx := strings.Index(upper, " FROM ")
	if selectIdx == -1 || fromIdx == -1 {
		return query
	}

	var cols []string
	cols = append(cols, "id")
	for _, dc := range info.dataCols {
		cols = append(cols, fmt.Sprintf("data->>'%s' AS \"%s\"", dc.jsonKey, dc.name))
	}
	cols = append(cols, "version")

	return query[:selectIdx+7] + strings.Join(cols, ", ") + query[fromIdx:]
}
